"""Analyze the ordering of v observations.

The v observations are generated by feature line index (L1 -> v1, L2 -> v2, etc.)
But cross-ratio formulas may assume points ordered geometrically along scan line.
"""

import numpy as np
from hsi_rgbd_calib.boards.li_wen_qiu_pattern import get_default_li_wen_qiu_pattern
from hsi_rgbd_calib.boards.geometry import intersect_lines_2d, cross_ratio_1d
from hsi_rgbd_calib.cal_method.li_wen_qiu.sim import simulate_views, NoiseConfig
from hsi_rgbd_calib.cal_method.li_wen_qiu.projection import (
    compute_scan_line_in_pattern, 
    compute_transform_pattern_to_linescan
)

pattern = get_default_li_wen_qiu_pattern()
wp1, wp2 = pattern.wp1, pattern.wp2

# Simulate
noise = NoiseConfig(sigma_v=0.0)
sim_result = simulate_views(n_views=1, noise_config=noise, seed=42)
gt = sim_result.ground_truth
view = sim_result.views[0]

# Get scan line and intersections
R0, T0 = compute_transform_pattern_to_linescan(
    view.R_frame_pattern, view.T_frame_pattern, gt.R, gt.T
)
scan_line = compute_scan_line_in_pattern(R0, T0)

# True pattern points
P_true = []
for fl in pattern.feature_lines:
    pt = intersect_lines_2d(scan_line, fl)
    P_true.append(pt if pt else (0, 0))

v = view.v_observations

print("=" * 60)
print("ORDERING ANALYSIS")
print("=" * 60)
print()
print("Points indexed by FEATURE LINE:")
for i in range(6):
    print(f"  P{i+1} on L{i+1}: ({P_true[i][0]:.6f}, {P_true[i][1]:.6f}) -> v{i+1} = {v[i]:.2f}")
print()

# Sort by v value (pixel position along sensor)
sorted_indices = np.argsort(v)
print("Points sorted by v VALUE (geometric order along sensor):")
for rank, idx in enumerate(sorted_indices):
    print(f"  Rank {rank}: P{idx+1} v={v[idx]:.2f}")
print()

# Sort by Y coordinate (position along scan line in pattern coords)
y_coords = [P_true[i][1] for i in range(6)]
sorted_by_y = np.argsort(y_coords)
print("Points sorted by Y coordinate (position along scan line):")
for rank, idx in enumerate(sorted_by_y):
    print(f"  Rank {rank}: P{idx+1} Y={y_coords[idx]:.4f}, v={v[idx]:.2f}")
print()

# The paper's convention may use GEOMETRIC ordering
# Let's see what cross-ratios we get if we use v values sorted geometrically

v_sorted = v[sorted_indices]
print("v values in sorted order:", v_sorted)
print()

# Try classic cross-ratio: (v[0], v[1]; v[2], v[3]) for first 4 sorted points
print("Cross-ratios of geometrically sorted points:")
for combo in [(0,1,2,3), (1,2,3,4), (2,3,4,5)]:
    i,j,k,l = combo
    cr = cross_ratio_1d(v_sorted[i], v_sorted[j], v_sorted[k], v_sorted[l])
    orig_indices = sorted_indices[list(combo)]
    print(f"  CR(rank {combo}) = CR(P{orig_indices[0]+1},P{orig_indices[1]+1},P{orig_indices[2]+1},P{orig_indices[3]+1}) = {cr:.4f}")
